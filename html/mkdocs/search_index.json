{
    "docs": [
        {
            "location": "/", 
            "text": "Django rest messaging\n\n\nThe project provides a pluggable Facebook-like messaging API for Django Rest Framework.\n\n\nThis is a first release (you know, \"Release Early, Release Often\"...). The backend is fully tested - and working - and the javascript frontend is under way.\nI coded this in a lean perspective and want to see if the project sparks some interest. Any comments and suggestions are therefore very welcome!\n\n\n\n\nOverview\n\n\nThe project provides a Facebook-like messaging backend for django rest framework. It is composed of three parts: \n\n\n\n\ndjango-rest-messaging\n (rest messaging backend built with DRF),\n\n\ndjango-rest-messaging-centrifugo\n (allows you to build a real-time messaging service using websockets, by integrating django-rest-messaging and \ncentrifugo\n), and \n\n\ntheir javascript consumer (under development).\n\n\n\n\nEnvironment\n\n\nTested with\n\n\n\n\nPython (2.7, 3.3, 3.4, 3.5)\n\n\nDjango (1.6, 1.7, 1.8, 1.9)\n\n\nDRF (2.4, 3.0, 3.1, 3.2, 3.3, 3.4)\n\n\n\n\nInstallation, testing and documentation\n\n\nPlease start by installating the \nREST backend\n. Then you can optinally add the \nreal-time\n module and the javascript consumer. \n\n\nTODO\n\n\nFinish the javascript consumer.\nAdd file upload.", 
            "title": "The project"
        }, 
        {
            "location": "/#django-rest-messaging", 
            "text": "The project provides a pluggable Facebook-like messaging API for Django Rest Framework.  This is a first release (you know, \"Release Early, Release Often\"...). The backend is fully tested - and working - and the javascript frontend is under way.\nI coded this in a lean perspective and want to see if the project sparks some interest. Any comments and suggestions are therefore very welcome!", 
            "title": "Django rest messaging"
        }, 
        {
            "location": "/#overview", 
            "text": "The project provides a Facebook-like messaging backend for django rest framework. It is composed of three parts:    django-rest-messaging  (rest messaging backend built with DRF),  django-rest-messaging-centrifugo  (allows you to build a real-time messaging service using websockets, by integrating django-rest-messaging and  centrifugo ), and   their javascript consumer (under development).", 
            "title": "Overview"
        }, 
        {
            "location": "/#environment", 
            "text": "Tested with   Python (2.7, 3.3, 3.4, 3.5)  Django (1.6, 1.7, 1.8, 1.9)  DRF (2.4, 3.0, 3.1, 3.2, 3.3, 3.4)", 
            "title": "Environment"
        }, 
        {
            "location": "/#installation-testing-and-documentation", 
            "text": "Please start by installating the  REST backend . Then you can optinally add the  real-time  module and the javascript consumer.", 
            "title": "Installation, testing and documentation"
        }, 
        {
            "location": "/#todo", 
            "text": "Finish the javascript consumer.\nAdd file upload.", 
            "title": "TODO"
        }, 
        {
            "location": "/django-rest-messaging/", 
            "text": "REST: django-rest-messaging\n\n\nThe django-rest-messaging module is the base of the project. It provides all the logic and entry points for the messaging service. \n\n\nRequirements\n\n\n\n\nPython (2.7, 3.3, 3.4, 3.5)\n\n\nDjango (1.6, 1.7, 1.8, 1.9)\n\n\nDRF (2.4, 3.0, 3.1, 3.2, 3.3, 3.4)\n\n\n\n\nInstallation\n\n\nInstall using \npip\n...\n\n\n$ pip install django-rest-messaging\n# optionnal: if you want to browse the module's entrypoints\n$ pip install django-rest-swagger\n\n\n\n\nAdd the module to the installed apps.\n\n\n\n# settings.py\n\nINSTALLED_APPS=(\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.sites',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    # ...\n    'rest_messaging',\n    # optional, if you want to browse the entrypoints\n    'rest_framework_swagger',\n)\n\n\n\n\n\nAdd the django-rest-messaging middleware to your application.\n\n\n\n# settings.py\n\nMIDDLEWARE_CLASSES = (\n    'django.middleware.common.CommonMiddleware',\n    'django.contrib.sessions.middleware.SessionMiddleware',\n    'django.middleware.csrf.CsrfViewMiddleware',\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\n    'django.contrib.messages.middleware.MessageMiddleware',\n    # (...) your other middlewares\n    'rest_messaging.middleware.MessagingMiddleware'\n)\n\n\n\n\n\nAdd the project's urls.\n\n\n\n# urls.py\n\nurlpatterns = [\n    # (...) your other urls\n    url(r'^messaging/', include('rest_messaging.urls', namespace='rest_messaging')),\n    # optional, if you want to browse the entrypoints\n    url(r'^docs/', include('rest_framework_swagger.urls')),\n]\n\n\n\n\n\nThis is it. There are however a few settings you might want to change.\n\n\nSettings\n\n\nA few settings can be configured in your project's settings.py file:\n\n\nDaily messages limit\n\n\nBy default, django-rest-messaging does not limit the number of messages a participant can send. You can modify this behaviour by setting settings.REST_MESSAGING_DAILY_LIMIT_CALLBACK to a function that returns the max number of messages a user can send daily. For example:\n\n\n\n# my_module.my_file.py\nmax_daily_messages(*args, **kwargs):\n    \n \n    Your function will receive as arguments the Message (Django model) instance attributes.\n    It must return an integer defining the daily limit or None. \n    \n\n    # so for instance, if you whish to limit the number of messages to 50 every day\n    return 50\n\n\n# settings.py\nfrom my_module.my_file import max_daily_messages\nREST_MESSAGING_DAILY_LIMIT_CALLBACK = max_daily_messages\n\n\n\n\n\nFiltering participants\n\n\nYou can filter the participants that can be added to a thread. \nBy default, django-rest-messaging limits the number of participants to 10. You can modify this behaviour by setting settings.REST_MESSAGING_ADD_PARTICIPANTS_CALLBACK to a function that returns the acceptable users ids. For example:\n\n\n\n# my_module.my_file.py\nadd_paricipants_filter(request, *participants_ids):\n    \n \n    The function will receive as arguments \n    1. the request and \n    2. the ids of the participants that we try to add. \n    It must return a list containing the ids of the users that can be added in the thread. \n    \n\n    # so for instance, if you whish to allow messaging only between staff members you could do\n    valid_ids = []\n    staf_ids = User.objects.filter(is_staff=True).values_list('id', flat=True)\n    for id in participants_ids:\n        if id in staf_ids:\n            valid_ids.append(id)\n    return valid_ids\n\n\n# settings.py\nfrom my_module.my_file import add_paricipants_filter\nREST_MESSAGING_ADD_PARTICIPANTS_CALLBACK = add_paricipants_filter\n\n\n\n\n\nRemoving participants\n\n\nBy default, django-rest-messaging allow participants to quit a thread. It does not allow a participant to remove another participant. You can modify this behaviour by setting settings.REST_MESSAGING_REMOVE_PARTICIPANTS_CALLBACK to a function that returns True if the participant may be removed, False otherwise. For example:\n\n\n\n# my_module.my_file.py\nremove_paricipant_filter(request, *participants_ids):\n    \n \n    The function will receive as arguments \n    1. the request and \n    2. the participant instance we wan to remove. \n    It must return True if the participant can be remove, False otherwise. \n    \n\n    # so for instance, if admin only should be allowed to remove a user, we could do\n    if request.user.is_superuser:\n        return True\n    return False\n\n# settings.py\nfrom my_module.my_file import remove_paricipant_filter\nREST_MESSAGING_REMOVE_PARTICIPANTS_CALLBACK = remove_paricipant_filter\n\n\n\n\n\nAllowing duplicate threads\n\n\nBy default, django-rest-messaging will group messages involing the same participants. If one tries to create a thread involving participants that have already started a discussion, the message will be rattached to the existing thread. You can modify this behaviour by setting settings.REST_MESSAGING_THREAD_UNIQUE_FOR_ACTIVE_RECIPIENTS to False\n\n\n\n# settings.py\nREST_MESSAGING_THREAD_UNIQUE_FOR_ACTIVE_RECIPIENTS = False\n\n\n\n\n\nAdd information about participants\n\n\nWhen serializing messages, django-rest-messaging will by default return them with a list containing the id of their readers. No additionnal information about these readers will be provided simply because it might not be available (ie, because the information about the User is saved in an unacessible database). You might want to change this behaviour, for instance by providing their username too. This can be done by setting settings.REST_MESSAGING_SERIALIZE_PARTICIPANTS_CALLBACK to a function that returns the desired serialized User object. The callback will be automatically called by the thread serializer, which will use it to render the information about the thread's participants. The tests.test_serializers module provides such an example:\n\n\n\n# this example is taken from tests.test_serializers.py\n# my_module.my_file.py\n\nclass UserProfileSerializer(serializers.ModelSerializer):\n    \n Serializer for testing purpose only (for the ThreadSerializer callback). \n\n\n    image = compat_serializer_method_field('get_image')\n    contact = compat_serializer_method_field('get_contact')\n\n    class Meta:\n        model = User\n        fields = ('id', 'username', 'image', 'contact')\n\n    def get_image(self, obj):\n        return obj.profile.image\n\n    def get_contact(self, obj):\n        return obj.profile.contact\n\ndef _thread_serializer_callback(thread_instance):\n    \n Shows how ThreadSerializer can get access to data about the users, beyond their simple ids. \n\n    # we get all the participants' ids\n    participants_ids = [participant.id for participant in thread_instance.participants.all()]\n    # we can run the query we want usng this ids\n    # here we want the users and related information\n    users = User.objects.filter(id__in=participants_ids).select_related('profile')\n    # we call our custom serializer\n    serialized = UserProfileSerializer(users, many=True)\n    return serialized.data\n\n\n# settings.py\nfrom my_module.my_file import _thread_serializer_callback\nREST_MESSAGING_SERIALIZE_PARTICIPANTS_CALLBACK = _thread_serializer_callback\n\n\n\n\n\nEntrypoints\n\n\nEntrypoint are available through django-rest-swagger.\n\n\nTesting\n\n\nInstall testing requirements.\n\n\n$ pip install -r requirements.txt\n\n\n\n\nRun with runtests.\n\n\n$ ./runtests.py\n\n\n\n\nYou can also use the excellent \ntox\n testing tool to run the tests against all supported versions of Python and Django. Install tox globally, and then simply run:\n\n\n$ tox\n\n\n\n\nDocumentation\n\n\nTo build the documentation, you'll need to install \nmkdocs\n.\n\n\n$ pip install mkdocs\n\n\n\n\nTo preview the documentation:\n\n\n$ mkdocs serve\nRunning at: http://127.0.0.1:8000/\n\n\n\n\nTo build the documentation:\n\n\n$ mkdocs build", 
            "title": "REST"
        }, 
        {
            "location": "/django-rest-messaging/#rest-django-rest-messaging", 
            "text": "The django-rest-messaging module is the base of the project. It provides all the logic and entry points for the messaging service.", 
            "title": "REST: django-rest-messaging"
        }, 
        {
            "location": "/django-rest-messaging/#requirements", 
            "text": "Python (2.7, 3.3, 3.4, 3.5)  Django (1.6, 1.7, 1.8, 1.9)  DRF (2.4, 3.0, 3.1, 3.2, 3.3, 3.4)", 
            "title": "Requirements"
        }, 
        {
            "location": "/django-rest-messaging/#installation", 
            "text": "Install using  pip ...  $ pip install django-rest-messaging\n# optionnal: if you want to browse the module's entrypoints\n$ pip install django-rest-swagger  Add the module to the installed apps.  \n# settings.py\n\nINSTALLED_APPS=(\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.sites',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    # ...\n    'rest_messaging',\n    # optional, if you want to browse the entrypoints\n    'rest_framework_swagger',\n)  Add the django-rest-messaging middleware to your application.  \n# settings.py\n\nMIDDLEWARE_CLASSES = (\n    'django.middleware.common.CommonMiddleware',\n    'django.contrib.sessions.middleware.SessionMiddleware',\n    'django.middleware.csrf.CsrfViewMiddleware',\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\n    'django.contrib.messages.middleware.MessageMiddleware',\n    # (...) your other middlewares\n    'rest_messaging.middleware.MessagingMiddleware'\n)  Add the project's urls.  \n# urls.py\n\nurlpatterns = [\n    # (...) your other urls\n    url(r'^messaging/', include('rest_messaging.urls', namespace='rest_messaging')),\n    # optional, if you want to browse the entrypoints\n    url(r'^docs/', include('rest_framework_swagger.urls')),\n]  This is it. There are however a few settings you might want to change.", 
            "title": "Installation"
        }, 
        {
            "location": "/django-rest-messaging/#settings", 
            "text": "A few settings can be configured in your project's settings.py file:", 
            "title": "Settings"
        }, 
        {
            "location": "/django-rest-messaging/#daily-messages-limit", 
            "text": "By default, django-rest-messaging does not limit the number of messages a participant can send. You can modify this behaviour by setting settings.REST_MESSAGING_DAILY_LIMIT_CALLBACK to a function that returns the max number of messages a user can send daily. For example:  \n# my_module.my_file.py\nmax_daily_messages(*args, **kwargs):\n      \n    Your function will receive as arguments the Message (Django model) instance attributes.\n    It must return an integer defining the daily limit or None. \n     \n    # so for instance, if you whish to limit the number of messages to 50 every day\n    return 50\n\n\n# settings.py\nfrom my_module.my_file import max_daily_messages\nREST_MESSAGING_DAILY_LIMIT_CALLBACK = max_daily_messages", 
            "title": "Daily messages limit"
        }, 
        {
            "location": "/django-rest-messaging/#filtering-participants", 
            "text": "You can filter the participants that can be added to a thread. \nBy default, django-rest-messaging limits the number of participants to 10. You can modify this behaviour by setting settings.REST_MESSAGING_ADD_PARTICIPANTS_CALLBACK to a function that returns the acceptable users ids. For example:  \n# my_module.my_file.py\nadd_paricipants_filter(request, *participants_ids):\n      \n    The function will receive as arguments \n    1. the request and \n    2. the ids of the participants that we try to add. \n    It must return a list containing the ids of the users that can be added in the thread. \n     \n    # so for instance, if you whish to allow messaging only between staff members you could do\n    valid_ids = []\n    staf_ids = User.objects.filter(is_staff=True).values_list('id', flat=True)\n    for id in participants_ids:\n        if id in staf_ids:\n            valid_ids.append(id)\n    return valid_ids\n\n\n# settings.py\nfrom my_module.my_file import add_paricipants_filter\nREST_MESSAGING_ADD_PARTICIPANTS_CALLBACK = add_paricipants_filter", 
            "title": "Filtering participants"
        }, 
        {
            "location": "/django-rest-messaging/#removing-participants", 
            "text": "By default, django-rest-messaging allow participants to quit a thread. It does not allow a participant to remove another participant. You can modify this behaviour by setting settings.REST_MESSAGING_REMOVE_PARTICIPANTS_CALLBACK to a function that returns True if the participant may be removed, False otherwise. For example:  \n# my_module.my_file.py\nremove_paricipant_filter(request, *participants_ids):\n      \n    The function will receive as arguments \n    1. the request and \n    2. the participant instance we wan to remove. \n    It must return True if the participant can be remove, False otherwise. \n     \n    # so for instance, if admin only should be allowed to remove a user, we could do\n    if request.user.is_superuser:\n        return True\n    return False\n\n# settings.py\nfrom my_module.my_file import remove_paricipant_filter\nREST_MESSAGING_REMOVE_PARTICIPANTS_CALLBACK = remove_paricipant_filter", 
            "title": "Removing participants"
        }, 
        {
            "location": "/django-rest-messaging/#allowing-duplicate-threads", 
            "text": "By default, django-rest-messaging will group messages involing the same participants. If one tries to create a thread involving participants that have already started a discussion, the message will be rattached to the existing thread. You can modify this behaviour by setting settings.REST_MESSAGING_THREAD_UNIQUE_FOR_ACTIVE_RECIPIENTS to False  \n# settings.py\nREST_MESSAGING_THREAD_UNIQUE_FOR_ACTIVE_RECIPIENTS = False", 
            "title": "Allowing duplicate threads"
        }, 
        {
            "location": "/django-rest-messaging/#add-information-about-participants", 
            "text": "When serializing messages, django-rest-messaging will by default return them with a list containing the id of their readers. No additionnal information about these readers will be provided simply because it might not be available (ie, because the information about the User is saved in an unacessible database). You might want to change this behaviour, for instance by providing their username too. This can be done by setting settings.REST_MESSAGING_SERIALIZE_PARTICIPANTS_CALLBACK to a function that returns the desired serialized User object. The callback will be automatically called by the thread serializer, which will use it to render the information about the thread's participants. The tests.test_serializers module provides such an example:  \n# this example is taken from tests.test_serializers.py\n# my_module.my_file.py\n\nclass UserProfileSerializer(serializers.ModelSerializer):\n      Serializer for testing purpose only (for the ThreadSerializer callback).  \n\n    image = compat_serializer_method_field('get_image')\n    contact = compat_serializer_method_field('get_contact')\n\n    class Meta:\n        model = User\n        fields = ('id', 'username', 'image', 'contact')\n\n    def get_image(self, obj):\n        return obj.profile.image\n\n    def get_contact(self, obj):\n        return obj.profile.contact\n\ndef _thread_serializer_callback(thread_instance):\n      Shows how ThreadSerializer can get access to data about the users, beyond their simple ids.  \n    # we get all the participants' ids\n    participants_ids = [participant.id for participant in thread_instance.participants.all()]\n    # we can run the query we want usng this ids\n    # here we want the users and related information\n    users = User.objects.filter(id__in=participants_ids).select_related('profile')\n    # we call our custom serializer\n    serialized = UserProfileSerializer(users, many=True)\n    return serialized.data\n\n\n# settings.py\nfrom my_module.my_file import _thread_serializer_callback\nREST_MESSAGING_SERIALIZE_PARTICIPANTS_CALLBACK = _thread_serializer_callback", 
            "title": "Add information about participants"
        }, 
        {
            "location": "/django-rest-messaging/#entrypoints", 
            "text": "Entrypoint are available through django-rest-swagger.", 
            "title": "Entrypoints"
        }, 
        {
            "location": "/django-rest-messaging/#testing", 
            "text": "Install testing requirements.  $ pip install -r requirements.txt  Run with runtests.  $ ./runtests.py  You can also use the excellent  tox  testing tool to run the tests against all supported versions of Python and Django. Install tox globally, and then simply run:  $ tox", 
            "title": "Testing"
        }, 
        {
            "location": "/django-rest-messaging/#documentation", 
            "text": "To build the documentation, you'll need to install  mkdocs .  $ pip install mkdocs  To preview the documentation:  $ mkdocs serve\nRunning at: http://127.0.0.1:8000/  To build the documentation:  $ mkdocs build", 
            "title": "Documentation"
        }, 
        {
            "location": "/django-rest-messaging-centrifugo/", 
            "text": "Real-time: django-rest-messaging-centrifugo\n\n\nThe django-rest-messaging-centrifugo module extends the django-rest-messaging module. It adds real-time messaging capabilities, by integrating django-rest-messaging and \ncentrifugo\n.\n\n\nRequirements\n\n\n\n\nPython (2.7, 3.3, 3.4, 3.5)\n\n\nDjango (1.7, 1.8, 1.9)\n\n\nDRF (2.4, 3.0, 3.1, 3.2, 3.3, 3.4)\n\n\n\n\nInstallation\n\n\nInstall centrifugo\n\n\nDownload centrifugo as expplained \nhere\n, and move it to /usr/bin/. You shuold have a /usr/bin/centrifugo executable. You can now check the installation is successfull by running\n\n\n$ cd /usr/bin\n$ ./centrifugo -h\n\n\n\n\nCreate a config.json file\n\n\nCreate a config.json file. You can copy the following one (just change the \"secret\" key, the other elements may be left as is). The file should be placed in a directory you have access to when launching centrifugo.\n\n\n# /path/to/config.json\n{\n  \nsecret\n: \nsecret\n, # change this to an unguessable string\n  \nanonymous\n: false,\n  \npublish\n: false,\n  \nwatch\n: false,\n  \npresence\n: true,\n  \njoin_leave\n: false,\n  \nhistory_size\n: 0,\n  \nhistory_lifetime\n: 0,\n  \nnamespaces\n: [\n    {\n      \nname\n: \nmessages\n,\n      \nanonymous\n: false\n    },\n    {\n      \nname\n: \nthreads\n,\n      \nanonymous\n: false\n    }\n  ]\n}\n\n\n\n\nLaunch centrifugo\n\n\nDownload centrifugo as expplained \nhere\n, and move it to /usr/bin/. You should have a /usr/bin/centrifugo executable. You can now check the installation is successfull by running \n\n\n# /usr/bin\n# port 8802 is for example purpose only. Note that centrifugo runs by default on port 8000, which can compete with your regular Django port\n$ ./centrifugo --config=/path/to/config.json --port=8802 \n\n\n\n\nThere are other command line options (address, engine etc.). See \nhere\n.\n\n\nFor information, you can see an additionnal example of how we launched centrifugo for the tests in django-rest-messaging-centrifugo/tests/test_integration.py (in setUpClass).\n\n\nInstall django-rest-messaging-centrifugo\n\n\n$ pip install django-rest-messaging-centrifugo\n\n\n\n\nAdd the module to the installed apps.\n\n\n\n# settings.py\n\nINSTALLED_APPS=(\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.sites',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    # ...\n    'rest_messaging',\n    'rest_messaging_centrifugo',\n)\n\n\n\n\n\nAdd additionnal configuration.\n\n\n\n# settings.py\n\n# django-rest-messaging-centrifugo config\nCENTRIFUGO_PORT = 8802 # the port on which centrifugo shall run, as set in config.json (see above)\nCENTRIFUGO_MESSAGE_NAMESPACE = \nmessages\n # the centrifugo message channel, do not change this value\nCENTRIFUGO_THREAD_NAMESPACE = \nthreads\n # the centrifugo thread channel, do not change this value\n# centrifugo config\n# note that the following settings refer to centrifugE_... \n# because it is the old name of the project\nCENTRIFUGE_ADDRESS = 'http://localhost:{0}/'.format(CENTRIFUGO_PORT) # change this to your domain/your port in production\nCENTRIFUGE_SECRET = 'secret' # change this to the key you put in config.json (see above)\nCENTRIFUGE_TIMEOUT = 5 \n\n\n\n\n\nAdd the project's urls.\n\n\n\n# urls.py\n\nurlpatterns = [\n    # (...) your other urls\n    # do not forget to include django-rest-messaging\n    url(r'^messaging/', include('rest_messaging.urls', namespace='rest_messaging')),\n    url(r'^messaging/centrifugo/', include('rest_messaging_centrifugo.urls', namespace='rest_messaging_centrifugo')),\n]\n\n\n\n\n\nExamples\n\n\nA full example will be available when the javascript consumer will be available. In the meantime, you can refer to the tests: django-rest-messaging-centrifugo/tests/test_integration.py and django-rest-messaging-centrifugo/tests/templates/tests/index.html go through the whole process of starting connections, identifying available channels and publishing new messages. \n\n\nTesting\n\n\nInstall testing requirements.\n\n\n$ pip install -r requirements.txt\n\n\n\n\nRun with runtests.\n\n\n$ ./runtests.py\n\n\n\n\nYou can also use the excellent \ntox\n testing tool to run the tests against all supported versions of Python and Django. Install tox globally, and then simply run:\n\n\n$ tox\n\n\n\n\nDocumentation\n\n\nThe documentation of the whole project has been included in django-rest-messaging, on which the other modules rely.", 
            "title": "Real-time"
        }, 
        {
            "location": "/django-rest-messaging-centrifugo/#real-time-django-rest-messaging-centrifugo", 
            "text": "The django-rest-messaging-centrifugo module extends the django-rest-messaging module. It adds real-time messaging capabilities, by integrating django-rest-messaging and  centrifugo .", 
            "title": "Real-time: django-rest-messaging-centrifugo"
        }, 
        {
            "location": "/django-rest-messaging-centrifugo/#requirements", 
            "text": "Python (2.7, 3.3, 3.4, 3.5)  Django (1.7, 1.8, 1.9)  DRF (2.4, 3.0, 3.1, 3.2, 3.3, 3.4)", 
            "title": "Requirements"
        }, 
        {
            "location": "/django-rest-messaging-centrifugo/#installation", 
            "text": "", 
            "title": "Installation"
        }, 
        {
            "location": "/django-rest-messaging-centrifugo/#install-centrifugo", 
            "text": "Download centrifugo as expplained  here , and move it to /usr/bin/. You shuold have a /usr/bin/centrifugo executable. You can now check the installation is successfull by running  $ cd /usr/bin\n$ ./centrifugo -h", 
            "title": "Install centrifugo"
        }, 
        {
            "location": "/django-rest-messaging-centrifugo/#create-a-configjson-file", 
            "text": "Create a config.json file. You can copy the following one (just change the \"secret\" key, the other elements may be left as is). The file should be placed in a directory you have access to when launching centrifugo.  # /path/to/config.json\n{\n   secret :  secret , # change this to an unguessable string\n   anonymous : false,\n   publish : false,\n   watch : false,\n   presence : true,\n   join_leave : false,\n   history_size : 0,\n   history_lifetime : 0,\n   namespaces : [\n    {\n       name :  messages ,\n       anonymous : false\n    },\n    {\n       name :  threads ,\n       anonymous : false\n    }\n  ]\n}", 
            "title": "Create a config.json file"
        }, 
        {
            "location": "/django-rest-messaging-centrifugo/#launch-centrifugo", 
            "text": "Download centrifugo as expplained  here , and move it to /usr/bin/. You should have a /usr/bin/centrifugo executable. You can now check the installation is successfull by running   # /usr/bin\n# port 8802 is for example purpose only. Note that centrifugo runs by default on port 8000, which can compete with your regular Django port\n$ ./centrifugo --config=/path/to/config.json --port=8802   There are other command line options (address, engine etc.). See  here .  For information, you can see an additionnal example of how we launched centrifugo for the tests in django-rest-messaging-centrifugo/tests/test_integration.py (in setUpClass).", 
            "title": "Launch centrifugo"
        }, 
        {
            "location": "/django-rest-messaging-centrifugo/#install-django-rest-messaging-centrifugo", 
            "text": "$ pip install django-rest-messaging-centrifugo  Add the module to the installed apps.  \n# settings.py\n\nINSTALLED_APPS=(\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.sites',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    # ...\n    'rest_messaging',\n    'rest_messaging_centrifugo',\n)  Add additionnal configuration.  \n# settings.py\n\n# django-rest-messaging-centrifugo config\nCENTRIFUGO_PORT = 8802 # the port on which centrifugo shall run, as set in config.json (see above)\nCENTRIFUGO_MESSAGE_NAMESPACE =  messages  # the centrifugo message channel, do not change this value\nCENTRIFUGO_THREAD_NAMESPACE =  threads  # the centrifugo thread channel, do not change this value\n# centrifugo config\n# note that the following settings refer to centrifugE_... \n# because it is the old name of the project\nCENTRIFUGE_ADDRESS = 'http://localhost:{0}/'.format(CENTRIFUGO_PORT) # change this to your domain/your port in production\nCENTRIFUGE_SECRET = 'secret' # change this to the key you put in config.json (see above)\nCENTRIFUGE_TIMEOUT = 5   Add the project's urls.  \n# urls.py\n\nurlpatterns = [\n    # (...) your other urls\n    # do not forget to include django-rest-messaging\n    url(r'^messaging/', include('rest_messaging.urls', namespace='rest_messaging')),\n    url(r'^messaging/centrifugo/', include('rest_messaging_centrifugo.urls', namespace='rest_messaging_centrifugo')),\n]", 
            "title": "Install django-rest-messaging-centrifugo"
        }, 
        {
            "location": "/django-rest-messaging-centrifugo/#examples", 
            "text": "A full example will be available when the javascript consumer will be available. In the meantime, you can refer to the tests: django-rest-messaging-centrifugo/tests/test_integration.py and django-rest-messaging-centrifugo/tests/templates/tests/index.html go through the whole process of starting connections, identifying available channels and publishing new messages.", 
            "title": "Examples"
        }, 
        {
            "location": "/django-rest-messaging-centrifugo/#testing", 
            "text": "Install testing requirements.  $ pip install -r requirements.txt  Run with runtests.  $ ./runtests.py  You can also use the excellent  tox  testing tool to run the tests against all supported versions of Python and Django. Install tox globally, and then simply run:  $ tox", 
            "title": "Testing"
        }, 
        {
            "location": "/django-rest-messaging-centrifugo/#documentation", 
            "text": "The documentation of the whole project has been included in django-rest-messaging, on which the other modules rely.", 
            "title": "Documentation"
        }, 
        {
            "location": "/django-rest-messaging-js/", 
            "text": "REST: django-rest-messaging\n\n\nThe django-rest-messaging module is the base of the project. It provides all the logic and entry points for the messaging service. \n\n\nRequirements\n\n\n\n\nPython (2.7, 3.3, 3.4, 3.5)\n\n\nDjango (1.6, 1.7, 1.8, 1.9)\n\n\nDRF (2.4, 3.0, 3.1, 3.2, 3.3, 3.4)\n\n\n\n\nInstallation\n\n\nInstall using \npip\n...\n\n\n$ pip install django-rest-messaging\n# optionnal: if you want to browse the module's entrypoints\n$ pip install django-rest-swagger\n\n\n\n\nAdd the module to the installed apps.\n\n\n\n# settings.py\n\nINSTALLED_APPS=(\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.sites',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    # ...\n    'rest_messaging',\n    # optional, if you want to browse the entrypoints\n    'rest_framework_swagger',\n)\n\n\n\n\n\nAdd the django-rest-messaging middleware to your application.\n\n\n\n# settings.py\n\nMIDDLEWARE_CLASSES = (\n    'django.middleware.common.CommonMiddleware',\n    'django.contrib.sessions.middleware.SessionMiddleware',\n    'django.middleware.csrf.CsrfViewMiddleware',\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\n    'django.contrib.messages.middleware.MessageMiddleware',\n    # (...) your other middlewares\n    'rest_messaging.middleware.MessagingMiddleware'\n)\n\n\n\n\n\nAdd the project's urls.\n\n\n\n# urls.py\n\nurlpatterns = [\n    # (...) your other urls\n    url(r'^messaging/', include('rest_messaging.urls', namespace='rest_messaging')),\n    # optional, if you want to browse the entrypoints\n    url(r'^docs/', include('rest_framework_swagger.urls')),\n]\n\n\n\n\n\nThis is it. There are however a few settings you might want to change.\n\n\nSettings\n\n\nA few settings can be configured in your project's settings.py file:\n\n\nDaily messages limit\n\n\nBy default, django-rest-messaging does not limit the number of messages a participant can send. You can modify this behaviour by setting settings.REST_MESSAGING_DAILY_LIMIT_CALLBACK to a function that returns the max number of messages a user can send daily. For example:\n\n\n\n# my_module.my_file.py\nmax_daily_messages(*args, **kwargs):\n    \n \n    Your function will receive as arguments the Message (Django model) instance attributes.\n    It must return an integer defining the daily limit or None. \n    \n\n    # so for instance, if you whish to limit the number of messages to 50 every day\n    return 50\n\n\n# settings.py\nfrom my_module.my_file import max_daily_messages\nREST_MESSAGING_DAILY_LIMIT_CALLBACK = max_daily_messages\n\n\n\n\n\nFiltering participants\n\n\nYou can filter the participants that can be added to a thread. \nBy default, django-rest-messaging limits the number of participants to 10. You can modify this behaviour by setting settings.REST_MESSAGING_ADD_PARTICIPANTS_CALLBACK to a function that returns the acceptable users ids. For example:\n\n\n\n# my_module.my_file.py\nadd_paricipants_filter(request, *participants_ids):\n    \n \n    The function will receive as arguments \n    1. the request and \n    2. the ids of the participants that we try to add. \n    It must return a list containing the ids of the users that can be added in the thread. \n    \n\n    # so for instance, if you whish to allow messaging only between staff members you could do\n    valid_ids = []\n    staf_ids = User.objects.filter(is_staff=True).values_list('id', flat=True)\n    for id in participants_ids:\n        if id in staf_ids:\n            valid_ids.append(id)\n    return valid_ids\n\n\n# settings.py\nfrom my_module.my_file import add_paricipants_filter\nREST_MESSAGING_ADD_PARTICIPANTS_CALLBACK = add_paricipants_filter\n\n\n\n\n\nRemoving participants\n\n\nBy default, django-rest-messaging allow participants to quit a thread. It does not allow a participant to remove another participant. You can modify this behaviour by setting settings.REST_MESSAGING_REMOVE_PARTICIPANTS_CALLBACK to a function that returns True if the participant may be removed, False otherwise. For example:\n\n\n\n# my_module.my_file.py\nremove_paricipant_filter(request, *participants_ids):\n    \n \n    The function will receive as arguments \n    1. the request and \n    2. the participant instance we wan to remove. \n    It must return True if the participant can be remove, False otherwise. \n    \n\n    # so for instance, if admin only should be allowed to remove a user, we could do\n    if request.user.is_superuser:\n        return True\n    return False\n\n# settings.py\nfrom my_module.my_file import remove_paricipant_filter\nREST_MESSAGING_REMOVE_PARTICIPANTS_CALLBACK = remove_paricipant_filter\n\n\n\n\n\nAllowing duplicate threads\n\n\nBy default, django-rest-messaging will group messages involing the same participants. If one tries to create a thread involving participants that have already started a discussion, the message will be rattached to the existing thread. You can modify this behaviour by setting settings.REST_MESSAGING_THREAD_UNIQUE_FOR_ACTIVE_RECIPIENTS to False\n\n\n\n# settings.py\nREST_MESSAGING_THREAD_UNIQUE_FOR_ACTIVE_RECIPIENTS = False\n\n\n\n\n\nAdd information about participants\n\n\nWhen serializing messages, django-rest-messaging will by default return them with a list containing the id of their readers. No additionnal information about these readers will be provided simply because it might not be available (ie, because the information about the User is saved in an unacessible database). You might want to change this behaviour, for instance by providing their username too. This can be done by setting settings.REST_MESSAGING_SERIALIZE_PARTICIPANTS_CALLBACK to a function that returns the desired serialized User object. The callback will be automatically called by the thread serializer, which will use it to render the information about the thread's participants. The tests.test_serializers module provides such an example:\n\n\n\n# this example is taken from tests.test_serializers.py\n# my_module.my_file.py\n\nclass UserProfileSerializer(serializers.ModelSerializer):\n    \n Serializer for testing purpose only (for the ThreadSerializer callback). \n\n\n    image = compat_serializer_method_field('get_image')\n    contact = compat_serializer_method_field('get_contact')\n\n    class Meta:\n        model = User\n        fields = ('id', 'username', 'image', 'contact')\n\n    def get_image(self, obj):\n        return obj.profile.image\n\n    def get_contact(self, obj):\n        return obj.profile.contact\n\ndef _thread_serializer_callback(thread_instance):\n    \n Shows how ThreadSerializer can get access to data about the users, beyond their simple ids. \n\n    # we get all the participants' ids\n    participants_ids = [participant.id for participant in thread_instance.participants.all()]\n    # we can run the query we want usng this ids\n    # here we want the users and related information\n    users = User.objects.filter(id__in=participants_ids).select_related('profile')\n    # we call our custom serializer\n    serialized = UserProfileSerializer(users, many=True)\n    return serialized.data\n\n\n# settings.py\nfrom my_module.my_file import _thread_serializer_callback\nREST_MESSAGING_SERIALIZE_PARTICIPANTS_CALLBACK = _thread_serializer_callback\n\n\n\n\n\nEntrypoints\n\n\nEntrypoint are available through django-rest-swagger.\n\n\nTesting\n\n\nInstall testing requirements.\n\n\n$ pip install -r requirements.txt\n\n\n\n\nRun with runtests.\n\n\n$ ./runtests.py\n\n\n\n\nYou can also use the excellent \ntox\n testing tool to run the tests against all supported versions of Python and Django. Install tox globally, and then simply run:\n\n\n$ tox\n\n\n\n\nDocumentation\n\n\nTo build the documentation, you'll need to install \nmkdocs\n.\n\n\n$ pip install mkdocs\n\n\n\n\nTo preview the documentation:\n\n\n$ mkdocs serve\nRunning at: http://127.0.0.1:8000/\n\n\n\n\nTo build the documentation:\n\n\n$ mkdocs build", 
            "title": "React.js"
        }, 
        {
            "location": "/django-rest-messaging-js/#rest-django-rest-messaging", 
            "text": "The django-rest-messaging module is the base of the project. It provides all the logic and entry points for the messaging service.", 
            "title": "REST: django-rest-messaging"
        }, 
        {
            "location": "/django-rest-messaging-js/#requirements", 
            "text": "Python (2.7, 3.3, 3.4, 3.5)  Django (1.6, 1.7, 1.8, 1.9)  DRF (2.4, 3.0, 3.1, 3.2, 3.3, 3.4)", 
            "title": "Requirements"
        }, 
        {
            "location": "/django-rest-messaging-js/#installation", 
            "text": "Install using  pip ...  $ pip install django-rest-messaging\n# optionnal: if you want to browse the module's entrypoints\n$ pip install django-rest-swagger  Add the module to the installed apps.  \n# settings.py\n\nINSTALLED_APPS=(\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.sites',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    # ...\n    'rest_messaging',\n    # optional, if you want to browse the entrypoints\n    'rest_framework_swagger',\n)  Add the django-rest-messaging middleware to your application.  \n# settings.py\n\nMIDDLEWARE_CLASSES = (\n    'django.middleware.common.CommonMiddleware',\n    'django.contrib.sessions.middleware.SessionMiddleware',\n    'django.middleware.csrf.CsrfViewMiddleware',\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\n    'django.contrib.messages.middleware.MessageMiddleware',\n    # (...) your other middlewares\n    'rest_messaging.middleware.MessagingMiddleware'\n)  Add the project's urls.  \n# urls.py\n\nurlpatterns = [\n    # (...) your other urls\n    url(r'^messaging/', include('rest_messaging.urls', namespace='rest_messaging')),\n    # optional, if you want to browse the entrypoints\n    url(r'^docs/', include('rest_framework_swagger.urls')),\n]  This is it. There are however a few settings you might want to change.", 
            "title": "Installation"
        }, 
        {
            "location": "/django-rest-messaging-js/#settings", 
            "text": "A few settings can be configured in your project's settings.py file:", 
            "title": "Settings"
        }, 
        {
            "location": "/django-rest-messaging-js/#daily-messages-limit", 
            "text": "By default, django-rest-messaging does not limit the number of messages a participant can send. You can modify this behaviour by setting settings.REST_MESSAGING_DAILY_LIMIT_CALLBACK to a function that returns the max number of messages a user can send daily. For example:  \n# my_module.my_file.py\nmax_daily_messages(*args, **kwargs):\n      \n    Your function will receive as arguments the Message (Django model) instance attributes.\n    It must return an integer defining the daily limit or None. \n     \n    # so for instance, if you whish to limit the number of messages to 50 every day\n    return 50\n\n\n# settings.py\nfrom my_module.my_file import max_daily_messages\nREST_MESSAGING_DAILY_LIMIT_CALLBACK = max_daily_messages", 
            "title": "Daily messages limit"
        }, 
        {
            "location": "/django-rest-messaging-js/#filtering-participants", 
            "text": "You can filter the participants that can be added to a thread. \nBy default, django-rest-messaging limits the number of participants to 10. You can modify this behaviour by setting settings.REST_MESSAGING_ADD_PARTICIPANTS_CALLBACK to a function that returns the acceptable users ids. For example:  \n# my_module.my_file.py\nadd_paricipants_filter(request, *participants_ids):\n      \n    The function will receive as arguments \n    1. the request and \n    2. the ids of the participants that we try to add. \n    It must return a list containing the ids of the users that can be added in the thread. \n     \n    # so for instance, if you whish to allow messaging only between staff members you could do\n    valid_ids = []\n    staf_ids = User.objects.filter(is_staff=True).values_list('id', flat=True)\n    for id in participants_ids:\n        if id in staf_ids:\n            valid_ids.append(id)\n    return valid_ids\n\n\n# settings.py\nfrom my_module.my_file import add_paricipants_filter\nREST_MESSAGING_ADD_PARTICIPANTS_CALLBACK = add_paricipants_filter", 
            "title": "Filtering participants"
        }, 
        {
            "location": "/django-rest-messaging-js/#removing-participants", 
            "text": "By default, django-rest-messaging allow participants to quit a thread. It does not allow a participant to remove another participant. You can modify this behaviour by setting settings.REST_MESSAGING_REMOVE_PARTICIPANTS_CALLBACK to a function that returns True if the participant may be removed, False otherwise. For example:  \n# my_module.my_file.py\nremove_paricipant_filter(request, *participants_ids):\n      \n    The function will receive as arguments \n    1. the request and \n    2. the participant instance we wan to remove. \n    It must return True if the participant can be remove, False otherwise. \n     \n    # so for instance, if admin only should be allowed to remove a user, we could do\n    if request.user.is_superuser:\n        return True\n    return False\n\n# settings.py\nfrom my_module.my_file import remove_paricipant_filter\nREST_MESSAGING_REMOVE_PARTICIPANTS_CALLBACK = remove_paricipant_filter", 
            "title": "Removing participants"
        }, 
        {
            "location": "/django-rest-messaging-js/#allowing-duplicate-threads", 
            "text": "By default, django-rest-messaging will group messages involing the same participants. If one tries to create a thread involving participants that have already started a discussion, the message will be rattached to the existing thread. You can modify this behaviour by setting settings.REST_MESSAGING_THREAD_UNIQUE_FOR_ACTIVE_RECIPIENTS to False  \n# settings.py\nREST_MESSAGING_THREAD_UNIQUE_FOR_ACTIVE_RECIPIENTS = False", 
            "title": "Allowing duplicate threads"
        }, 
        {
            "location": "/django-rest-messaging-js/#add-information-about-participants", 
            "text": "When serializing messages, django-rest-messaging will by default return them with a list containing the id of their readers. No additionnal information about these readers will be provided simply because it might not be available (ie, because the information about the User is saved in an unacessible database). You might want to change this behaviour, for instance by providing their username too. This can be done by setting settings.REST_MESSAGING_SERIALIZE_PARTICIPANTS_CALLBACK to a function that returns the desired serialized User object. The callback will be automatically called by the thread serializer, which will use it to render the information about the thread's participants. The tests.test_serializers module provides such an example:  \n# this example is taken from tests.test_serializers.py\n# my_module.my_file.py\n\nclass UserProfileSerializer(serializers.ModelSerializer):\n      Serializer for testing purpose only (for the ThreadSerializer callback).  \n\n    image = compat_serializer_method_field('get_image')\n    contact = compat_serializer_method_field('get_contact')\n\n    class Meta:\n        model = User\n        fields = ('id', 'username', 'image', 'contact')\n\n    def get_image(self, obj):\n        return obj.profile.image\n\n    def get_contact(self, obj):\n        return obj.profile.contact\n\ndef _thread_serializer_callback(thread_instance):\n      Shows how ThreadSerializer can get access to data about the users, beyond their simple ids.  \n    # we get all the participants' ids\n    participants_ids = [participant.id for participant in thread_instance.participants.all()]\n    # we can run the query we want usng this ids\n    # here we want the users and related information\n    users = User.objects.filter(id__in=participants_ids).select_related('profile')\n    # we call our custom serializer\n    serialized = UserProfileSerializer(users, many=True)\n    return serialized.data\n\n\n# settings.py\nfrom my_module.my_file import _thread_serializer_callback\nREST_MESSAGING_SERIALIZE_PARTICIPANTS_CALLBACK = _thread_serializer_callback", 
            "title": "Add information about participants"
        }, 
        {
            "location": "/django-rest-messaging-js/#entrypoints", 
            "text": "Entrypoint are available through django-rest-swagger.", 
            "title": "Entrypoints"
        }, 
        {
            "location": "/django-rest-messaging-js/#testing", 
            "text": "Install testing requirements.  $ pip install -r requirements.txt  Run with runtests.  $ ./runtests.py  You can also use the excellent  tox  testing tool to run the tests against all supported versions of Python and Django. Install tox globally, and then simply run:  $ tox", 
            "title": "Testing"
        }, 
        {
            "location": "/django-rest-messaging-js/#documentation", 
            "text": "To build the documentation, you'll need to install  mkdocs .  $ pip install mkdocs  To preview the documentation:  $ mkdocs serve\nRunning at: http://127.0.0.1:8000/  To build the documentation:  $ mkdocs build", 
            "title": "Documentation"
        }
    ]
}